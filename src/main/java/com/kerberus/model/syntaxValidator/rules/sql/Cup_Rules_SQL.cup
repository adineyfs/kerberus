/* ---------------------- 1st Part: User Code --------------------------------------------*/
package com.kerberus.model.syntaxValidator.rules.sql;

import java_cup.runtime.*; //Just import Symbols, maybe it's the only one we need
//import java.util.*;
import java.util.LinkedList;
import java.io.*;
import com.kerberus.model.syntaxValidator.rules.util.*;

// ---------------------- Code for parser,variables and methods ----------------------
parser code
{:
	// This list will store every error found in the syntax analysis process. SE -> Syntax errors
	public static LinkedList<TError> TableSE = new LinkedList<TError>();

	// This object has a list with all columns found and its table
	//public static ColumnEvalutator Columns = new ColumnEvaluator();

	public LinkedList<String> Tables  = new LinkedList<String>();
	public LinkedList<String> Columns = new LinkedList<String>();

	public  Scanner s;
  	public  int errors = 0, line, column;
  	public 	String the_error;
	public 	StringBuilder the_error_message;


	/* This is the error handler */
	public void report_error(String message, Object info) {

        /* Create a StringBuilder called 'm' with the string 'Error' in it. */
        StringBuilder m = new StringBuilder("\n\n---- Error message: " + message + "\n");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {

        	errors++;

            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0 && s.right >= 0) {

            	the_error = s.value.toString();
                
                m.append("--> Unexpected : " + the_error );
                m.append(" at line: "+(s.left));   
                m.append(", column: "+(s.right));

				the_error_message = m;
            }
        }
   
        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
	
:};

// -------------- Code for grammatical actions ------------------------------------------

action code 
{:
	
:}

/*---------------------- 2nd Part: Declarations --------------------------------------------*/



/* --- Non-Terminals | Branches of the tree --- */

non terminal _select, _from, _where, table_name,tab;

non terminal statement_group, statement;

non terminal select_s, select_part, from_part, where_part, cols,col;

non terminal w_condition, cond, log_oper,ari_oper, element;

non terminal update_s, update_part, set_cols,value;

non terminal delete_s;




/* --- Terminals | Branches of the tree --- */


// Reserved words
terminal SELECT, UPDATE, SET, DELETE, FROM, WHERE;

// Identifiers and numbers
terminal IDENTIFIER, INTEGER, REAL, LITERAL_STRING;
terminal QTABLENAME, TABDOTCOL; // Quoted table-names, table.column

// Operators 
terminal _EQU, _GT, _LT, _LET, _GET, _DIFF;

// Logial
terminal _AND,_OR;



/* Other characters */
terminal _COMMA;
terminal _STAR;

// Statement closure
terminal /*_SEMCOL1,*/_SEMCOL2;


// Lexical error
terminal ILLEGAL_CHAR;


// ------- Define which is the first production
// --------------------------------------------

start with statement_group;

// --------------------------------------------


/*---------------------- 3rd Part: Semantic Rules --------------------------------------------*/

statement_group ::=		statement_group statement _SEMCOL2
			  	  | 	statement _SEMCOL2
			  	  |		error _SEMCOL2
			  	  | 	error:err 	{: System.out.println(" Error in left: " + (errleft) + ", right: " + (errright) + "\n Here: " + err ); :};

statement 		::= 	select_s   
				  |  	delete_s
				  | 	update_s; 
				  //| 	insert_s    // ---- TO-DO ----


/* SELECT */

select_s		::=		select_part from_part 
				  |		select_part from_part where_part;

select_part		::= 	_select _STAR
			  	  | 	_select cols;

_select 		::=		SELECT;

cols			::= 	col _COMMA cols   
		  	  	  | 	col;
col				::= 	IDENTIFIER:col1 {: Columns.add(col1 + ""); :}
				  |		TABDOTCOL:col1  {: Columns.add(col1 + ""); :};



/* UPDATE */

update_s		::= 	update_part SET set_cols where_part;

update_part		::= 	UPDATE table_name;

set_cols		::= 	col:col1 _EQU value _COMMA set_cols {: Columns.add(col1 + ""); :} 
		  	  	  | 	col:col1 _EQU value		    	 	{: Columns.add(col1 + ""); :};


value 			::= 	INTEGER
				  | 	REAL
				  | 	LITERAL_STRING
				  | 	col;


/* DELETE */

delete_s		::= 	DELETE from_part where_part;




/* FROM */

from_part		::= 	_from table_name;

_from			::= 	FROM;



/* TABLE NAMES */

table_name		::= 	tab 
				  | 	tab IDENTIFIER;
				  
tab				::= 	IDENTIFIER:id {: Tables.add(id+""); :}
				  | 	QTABLENAME:id {: Tables.add(id.toString().replace("\"", "")); :};




/* WHERE */

where_part		::= 	_where w_condition;  

_where			::=		WHERE;

w_condition		::= 	cond log_oper w_condition
		  	  	  | 	cond;

cond 			::= 	element ari_oper element;

element    		::= 	IDENTIFIER
		  	  	  | 	INTEGER
		  	  	  | 	REAL
		  	  	  | 	LITERAL_STRING;

ari_oper  		::= 	_EQU 
		  	  	  | 	_GT 
		  	  	  | 	_LT 
		  	  	  | 	_LET 
		  	  	  | 	_GET 
		  	  	  | 	_DIFF;

log_oper    	::= 	_AND 
			  	  | 	_OR;
