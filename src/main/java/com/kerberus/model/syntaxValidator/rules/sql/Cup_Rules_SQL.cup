/* ---------------------- 1st Part: User Code --------------------------------------------*/
package com.kerberus.model.syntaxValidator.rules.sql;

import java_cup.runtime.*; //Just import Symbols, maybe it's the only one we need
//import java.util.*;
import java.util.LinkedList;
import java.io.*;
import com.kerberus.model.syntaxValidator.rules.util.*;

// ---------------------- Code for parser,variables and methods ----------------------
parser code
{:
	// This list will store every error found in the syntax analysis process. SE -> Syntax errors
	public static LinkedList<TError> TableSE = new LinkedList<TError>();

	// This object has a list with all columns found and its table
	//public static ColumnEvalutator Columns = new ColumnEvaluator();

	public LinkedList<String> Tables  = new LinkedList<String>();
	public LinkedList<String> Columns = new LinkedList<String>();

	public  Scanner s;
  	public  int errors = 0, line, column;
  	public 	String the_error = "";
	public 	StringBuilder the_error_message = new StringBuilder();

	public int selects_read = 0;
	public int updates_read = 0;
	public int deletes_read = 0;


	public void clean_lists() {
		TableSE = new LinkedList<TError>();
	}

	/* This is the error handler */
	public void report_error(String message, Object info) {

        /* Create a StringBuilder called 'm' with the string 'Error' in it. */
        StringBuilder m = new StringBuilder("\n\n---- Error message: " + message + "\n");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {

        	// Uncomment when Analyzer can handle multiple errors
			//errors++;
			errors = 1;

            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0 && s.right >= 0) {

            	
				the_error = (s.value == null) ? "Empty" : s.value.toString();
				//the_error = s.value.toString();
                
                m.append("--> Unexpected : " + the_error );
                m.append(" at line: "+(s.left));  
                m.append(", column: "+(s.right)); 

				the_error_message = m;
            }
        }
   
        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/

    public void report_fatal_error(String message, Object info) {
        //report_error(message, info);
		//the_error_message.append("\n\n---- Unknown syntax error ლ(ಠ_ಠლ)" + "\n");
		the_error_message.append("\n\n---- Unknown syntax error." + "\n");
    }
	
:};

// -------------- Code for grammatical actions ------------------------------------------

action code 
{:
	
:}

/*---------------------- 2nd Part: Declarations --------------------------------------------*/



/* --- Non-Terminals | Branches of the tree --- */

non terminal _select, _from, _where, table_name,table_name_mult,tab,tab_ali;

non terminal statement_group, statement,_semicolon;

non terminal select_s, select_part,select_part_sub;

non terminal col_el,aggregates,agg_count,count_exp;

non terminal from_part, where_part, cols,col,cl,col_ali;

non terminal element_in, in_list, in_exp, in_array, in_subquery;

non terminal joins_part,join_p,join_on,join_cond,join_c, join; // join_using_cols, join_using : future version

non terminal w_condition, cond, log_oper,cmp_oper, element;

non terminal update_s,_update,_set, update_part, ari_value;

non terminal set_exp_list, set_exp,ari_exp,par_exp,exp,_ari_opr,_asig_opr;  // elements for a small calculator

non terminal delete_s;




/* --- Terminals | Branches of the tree --- */


// Reserved words
terminal SELECT, UPDATE, SET, DELETE, FROM, WHERE;

// Joins
terminal NATURAL, LEFT, RIGHT,FULL, OUTER, INNER, JOIN; 	// USING : for future improvement


terminal AS,ON,IN, DISTINCT,NULL;

// Aggregated functions
terminal COUNT;

// Identifiers and numbers
terminal IDENTIFIER, INTEGER, REAL, LITERAL_STRING;
terminal QTABLENAME, TABDOTCOL,QCOLALIAS; // Quoted table-names, table.column, Quoted Column Alias

// Operators 
terminal _EQU, _GT, _LT, _LET, _GET, _DIFF;
terminal _PLUS, _MINUS, _DIVIDE; 

// Logical
terminal _AND,_OR;

// Special assignment operators -   += | -= | *= | /= | %= | &= | ^= | |=
terminal _PLUSEQ,_MINUSEQ,_TIMESEQ,_DIVIDEEQ,_MODEQ,_ANDEQ,_POWEQ,_OREQ;

/* Grouping operators */
terminal _OPENPAR,_CLOSEPAR;

/* Other characters */
terminal _COMMA;
terminal _STAR;

// Statement closure
terminal /*_SEMCOL1,*/_SEMCOL2;


// Lexical error
terminal ILLEGAL_CHAR;

/* -------------Precedence and Associatively of Terminals Section----------- */
/* Enter precedence declarations here*/

//Precedences added by Eclipse plugin
precedence nonassoc error;	// Inserted by Eclipse plugin | | 	_update table_name error
precedence left  _PLUS,_MINUS,_STAR,_DIVIDE;
precedence left  _EQU;




// ------- Define which is the first production
start with statement_group ;



/*---------------------- 3rd Part: Semantic Rules --------------------------------------------*/

statement_group ::=		statement_group statement
						{: System.out.println("statement_group ::= statement_group statement"); :}
			  	  | 	statement
			  	  		{: System.out.println("statement_group ::= statement"); :};

statement 		::= 	select_s   
						{: System.out.println("statement ::= select_s"); 	
						   selects_read++; :}
				  |  	delete_s
				  		{: System.out.println("statement ::= delete_s");
						   deletes_read++; :}
				  | 	update_s
				  		{: System.out.println("statement ::= update_s"); 
						   updates_read++; :};
				  //| 	insert_s    // ---- TO-DO ----

_semicolon 		::= 	_SEMCOL2
						{: System.out.println("_semicolon ::= _SEMICOL2"); :};

/* SELECT */

select_s		::=		select_part from_part _semicolon
						{: System.out.println("select_s ::= select_part from_part"); :}
				  |		select_part from_part where_part _semicolon
				  		{: System.out.println("select_s ::= select_part from_part where_part"); :}
				  |		select_part from_part joins_part _semicolon
				  		{: System.out.println("select_s ::= select_part from_part joins_part"); :}
				  |		select_part from_part joins_part where_part _semicolon
				  		{: System.out.println("select_s ::= select_part from_part joins_part where_part"); :};
				  
joins_part		::= 	join_p joins_part
						{: System.out.println("joins_part ::= join_p joins_part"); :}
				  | 	join_p
				  		{: System.out.println("joins_part ::= join_p"); :};		

join_p			::= 	NATURAL JOIN table_name
				  | 	JOIN table_name
				  //| 	JOIN table_name join_using   // future version improvement
				  | 	JOIN table_name join_cond
				  | 	join table_name join_cond;
				  
/*
	// For a future version : must validate that all column dont have qualifiers: tab.column 
	join_using 		::= 	USING _OPENPAR join_using_cols _CLOSEPAR;				  

	join_using_cols ::= 	cl _COMMA join_using_cols   
		  	  	 	  | 		cl;
*/
				  
join 			::=  	INNER JOIN
				  | 	LEFT  OUTER JOIN
				  | 	RIGHT OUTER JOIN
				  | 	FULL OUTER JOIN;				 

join_cond		::= 	ON join_c;


join_c			::= 	join_on log_oper join_c
				  |   	join_on;

join_on			::= 	element _EQU element;		  

select_part		::= 	_select _STAR
			  	  | 	_select DISTINCT cols
			  	  | 	_select cols;
		  	  	  /*|		SELECT error {: TError errors_found = new TError("",0,0,"Syntax Error","Incomplete SELECT statement");
				  	  	   		 TableSE.add(errors_found);  :};*/

_select 		::=		SELECT;

cols			::= 	col_el _COMMA cols   
		  	  	  | 	col_el;
				  	  	  
col_el 			::= 	aggregates
				  |     col;
				  
aggregates 		::= 	agg_count; // Add aggregate functions here

agg_count 		::=   	COUNT _OPENPAR count_exp _CLOSEPAR
				  |		COUNT _OPENPAR _STAR _CLOSEPAR;

count_exp 		::= 	DISTINCT cl
				  | 	DISTINCT NULL
				  | 	NULL
				  | 	cl;
				  
col				::= 	cl
				  | 	cl AS col_ali
				  | 	NULL 
				  | 	NULL AS col_ali; 

cl				::= 	IDENTIFIER:col1 {: Columns.add(col1 + ""); :}
				  |		TABDOTCOL:col1  {: Columns.add(col1 + ""); :}
				  | 	LITERAL_STRING;
				  
col_ali			::= 	QTABLENAME:t {: Tables.add(t+""); :}
				  | 	IDENTIFIER:t {: Tables.add(t+""); :}
				  | 	QCOLALIAS:t {: Tables.add(t+""); :};				



/* UPDATE */

update_s		::= 	update_part _set set_exp_list where_part _semicolon
				  		{: System.out.println("update_s	::= update_part _set set_cols where_part _semicolon"); :}
				  |  	update_part _set set_exp_list where_part error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Invalid UPDATE section. Missing semicolon (;).");
				  	  	   TableSE.add(errors_found);
						   System.out.println("update_s	::= update_part _set set_cols where_part errorerror.\nMissing semicolon on UPDATE."); :}
				  |  	update_part _set set_exp_list  error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","UPDATE error after set of columns.");
				  	  	   TableSE.add(errors_found);
						   System.out.println("update_s	::= update_part _set set_cols error"); :}
				  /*|  	update_part _set error
				  		{: System.out.println("update_s	::= update_part _set error"); :}*/
				  |  	update_part error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Incomplete UPDATE.");
				  	  	   TableSE.add(errors_found);
						   System.out.println("update_s	::= update_part error"); :}
				  |     _update error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Invalid UPDATE.");
				  	  	   TableSE.add(errors_found);
						   System.out.println("update_s	::= _update error"); :}
				  /*| 	_update error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Invalid statement.");
				  	  	   TableSE.add(errors_found);
						   System.out.println("Invalid UPDATE part. Check UPDATE."); :}*/;

_set 			::= 	SET
						{: System.out.println("_set ::= SET"); :};

update_part		::= 	_update table_name
						{: System.out.println("update_part ::= _update table_name"); :}
				  | 	error
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Invalid UPDATE.");
				  	  	   TableSE.add(errors_found); 
						   System.out.println("update_part ::= _update table_name"); :};

_update 		::= 	UPDATE
						{: System.out.println("_update ::= UPDATE"); :};

set_exp_list	::= 	set_exp _COMMA set_exp_list 
						{: System.out.println("set_exp_list	::= set_exp _COMMA set_exp_list "); :}
		  	  	  | 	set_exp
		  	  	  		{: System.out.println("set_exp_list	::= set_exp "); :}
		  	  	  | 	error
		  	  	  		{: TError errors_found = new TError("",0,0,"Syntax Error","Invalid set of columns in UPDATE");
				  	  	   TableSE.add(errors_found); 
						   System.out.println("set_cols	::=	error"); :}
		  	  	  ;

set_exp 		::= 	col _asig_opr ari_exp
				  | 	col _EQU LITERAL_STRING
				  		{: System.out.println("set_exp ::= col _EQU LITERAL_STRING"); :};

ari_exp     	::=     par_exp
              	  |     exp 
              	  |     ari_value;
              	  
ari_value 		::=		col
				  		{: System.out.println("value ::= col"); :}
				  | 	INTEGER
						{: System.out.println("value ::= INTEGER"); :}
				  | 	REAL
				  		{: System.out.println("value ::= value"); :};              	  
 
par_exp 		::= 	_OPENPAR ari_exp _CLOSEPAR;

exp 			::= 	ari_exp _ari_opr ari_exp; 
 
_ari_opr        ::=     _PLUS 
              	  |     _MINUS 
                  |     _STAR 
              	  |     _DIVIDE;

_asig_opr 		::= 	_EQU|_PLUSEQ|_MINUSEQ|_TIMESEQ|_DIVIDEEQ|_MODEQ|_ANDEQ|_POWEQ|_OREQ;
 


/* DELETE */

delete_s		::= 	DELETE FROM table_name where_part _semicolon
				  | 	DELETE error {: TError errors_found = new TError("",0,0,"Syntax Error","Invalid DELETE statement.");
				  	  			 		TableSE.add(errors_found);
										System.out.println("value ::= LITERAL_STRING"); :};




/* FROM: single and multiple tables */


from_part		::= 	_from table_name_mult;

table_name_mult ::= 	table_name _COMMA table_name_mult
				  |     table_name;

_from			::= 	FROM;



/* TABLE NAMES */

table_name		::= 	tab
				  		{: System.out.println("table_name ::= tab"); :}
				  | 	tab_ali 
						{: System.out.println("table_name ::= tab_ali"); :};

tab				::= 	IDENTIFIER:id 
						{: Tables.add(id+"");
						   System.out.println("tab ::= IDENTIFIER"); :};
				  
tab_ali 		::= 	IDENTIFIER:id1 IDENTIFIER:id2
						{: System.out.println("tab_ali ::= IDENTIFIER IDENTIFIER");	
						   Tables.add(id1+" "+id2); :}
				  | 	IDENTIFIER:id1 QTABLENAME:id2
				  		{: System.out.println("tab_ali ::= IDENTIFIER QTABLENAME"); 
						   Tables.add(id1+" "+id2); :};
		

/* WHERE */

where_part		::= 	_where w_condition
						{: System.out.println("where_part ::= _where w_condition"); :};  

_where			::=		WHERE
						{: System.out.println("_where ::= WHERE"); :};

w_condition		::= 	cond log_oper w_condition
						{: System.out.println("w_condition ::= cond log_oper w_condition"); :}
		  	  	  | 	cond
		  	  	  		{: System.out.println("w_condition ::= cond"); :};

cond 			::= 	element cmp_oper element
				  | 	element_in IN in_list;
				  
in_list 		::=  	_OPENPAR in_exp  _CLOSEPAR;

in_exp 			::= 	in_array
				  | 	in_subquery; 	
				  
in_subquery 	::= 	select_part_sub from_part
				  |		select_part_sub from_part where_part
				  |		select_part_sub from_part joins_part
				  |		select_part_sub from_part joins_part where_part;
				
select_part_sub ::= 	_select col; 				  

in_array 		::=  	element _COMMA in_array
				  | 	element;

element_in 		::=  	IDENTIFIER
				  | 	TABDOTCOL;

element    		::= 	IDENTIFIER
		  	  	  | 	INTEGER
		  	  	  | 	REAL
		  	  	  | 	LITERAL_STRING
		  	  	  | 	TABDOTCOL
		  	  	  | 	NULL;

cmp_oper  		::= 	_EQU 
		  	  	  | 	_GT 
		  	  	  | 	_LT 
		  	  	  | 	_LET 
		  	  	  | 	_GET 
		  	  	  | 	_DIFF;

log_oper    	::= 	_AND 
			  	  | 	_OR;

// ~~ CUP-ECLIPSE:CONFLICT-RES-RR ~~ 
 // After this the order of productions matters
/*
//Separated and moved by CUP Eclipse plugin
statement_group ::=  	error 
				  		{: System.out.println(".\nSyntax does not match any correct statement.\n\n\t( •_•)\n\n\t(•_• )\n\nTrying to break Kerberus?"); :};

//Separated and moved by CUP Eclipse plugin
update_s 		::=   	error
				  		{: System.out.println("Invalid update_statement."); :};
*/