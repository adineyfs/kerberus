/* ---------------------- 1st Part: User Code --------------------------------------------*/
package com.kerberus.model.syntaxValidator.rules.sql;

import java_cup.runtime.*; //Just import Symbols, maybe it's the only one we need
//import java.util.*;
import java.util.LinkedList;
import java.io.*;
import com.kerberus.model.syntaxValidator.rules.util.*;

// ---------------------- Code for parser,variables and methods ----------------------
parser code
{:
	// This list will store every error found in the syntax analysis process. SE -> Syntax errors
	public static LinkedList<TError> TableSE = new LinkedList<TError>();

	// This object has a list with all columns found and its table
	//public static ColumnEvalutator Columns = new ColumnEvaluator();

	public LinkedList<String> Tables  = new LinkedList<String>();
	public LinkedList<String> Columns = new LinkedList<String>();

	public  Scanner s;
  	public  int errors = 0, line, column;
  	public 	String the_error;
	public 	StringBuilder the_error_message;


	/* This is the error handler */
	public void report_error(String message, Object info) {

        /* Create a StringBuilder called 'm' with the string 'Error' in it. */
        StringBuilder m = new StringBuilder("\n\n---- Error message: " + message + "\n");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {

        	errors++;

            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0 && s.right >= 0) {

            	
				the_error = (s.value == null) ? "Empty" : s.value.toString();
				//the_error = s.value.toString();
                
                m.append("--> Unexpected : " + the_error );
                m.append(" at line: "+(s.left));   
                m.append(", column: "+(s.right));

				the_error_message = m;
            }
        }
   
        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
	
:};

// -------------- Code for grammatical actions ------------------------------------------

action code 
{:
	
:}

/*---------------------- 2nd Part: Declarations --------------------------------------------*/



/* --- Non-Terminals | Branches of the tree --- */

non terminal _select, _from, _where, table_name,table_name_mult,tab;

non terminal statement_group, statement;

non terminal select_s, select_part;

non terminal from_part, where_part, cols,col,cl,col_ali;

non terminal join_part,join_p,join_on,join_cond,join_c;

non terminal w_condition, cond, log_oper,ari_oper, element;

non terminal update_s, update_part, set_cols,value;

non terminal delete_s;




/* --- Terminals | Branches of the tree --- */


// Reserved words
terminal SELECT, UPDATE, SET, DELETE, FROM, WHERE,JOIN;

terminal AS,ON;

// Identifiers and numbers
terminal IDENTIFIER, INTEGER, REAL, LITERAL_STRING;
terminal QTABLENAME, TABDOTCOL,QCOLALIAS; // Quoted table-names, table.column, Quoted Column Alias

// Operators 
terminal _EQU, _GT, _LT, _LET, _GET, _DIFF;

// Logial
terminal _AND,_OR;



/* Other characters */
terminal _COMMA;
terminal _STAR;

// Statement closure
terminal /*_SEMCOL1,*/_SEMCOL2;


// Lexical error
terminal ILLEGAL_CHAR;


// ------- Define which is the first production
// --------------------------------------------

start with statement_group;

// --------------------------------------------


/*---------------------- 3rd Part: Semantic Rules --------------------------------------------*/

statement_group ::=		statement_group statement _SEMCOL2
			  	  | 	statement _SEMCOL2
			  	  | 	statement error 
			  	  		{: TError errors_found = new TError("",0,0,"Syntax Error","Missing semicolon (;)");
				  	  	   TableSE.add(errors_found);  :}
				  | 	error _SEMCOL2 
				  		{: TError errors_found = new TError("",0,0,"Syntax Error","Missing semicolon (;)");
				  	  	   TableSE.add(errors_found);  :}
			  	  | 	error
			  	  		{: TError errors_found = new TError("",0,0,"Syntax Error","Missing semicolon (;)");
				  	  	   TableSE.add(errors_found);  :};

statement 		::= 	select_s   
				  |  	delete_s
				  | 	update_s; 
				  //| 	insert_s    // ---- TO-DO ----


/* SELECT */

select_s		::=		select_part from_part
				  |		select_part from_part where_part
				  |		select_part from_part join_part
				  |		select_part from_part join_part where_part;
				  
join_part		::= 	join_p join_part
				  | 	join_p;		

join_p			::= 	JOIN table_name join_cond;

join_cond		::= 	ON join_c;


join_c			::= 	join_on log_oper join_c
				  |   	join_on;

join_on			::= 	element _EQU element;		  

select_part		::= 	_select _STAR
			  	  | 	_select cols;
		  	  	  /*|		SELECT error {: TError errors_found = new TError("",0,0,"Syntax Error","Incomplete SELECT statement");
				  	  	   		 TableSE.add(errors_found);  :};*/

_select 		::=		SELECT;

cols			::= 	col _COMMA cols   
		  	  	  | 	col;

col				::= 	cl
				  | 	cl AS col_ali; 

cl				::= 	IDENTIFIER:col1 {: Columns.add(col1 + ""); :}
				  |		TABDOTCOL:col1  {: Columns.add(col1 + ""); :};
				  
col_ali			::= 	QTABLENAME 
				  | 	IDENTIFIER
				  | 	QCOLALIAS;				



/* UPDATE */

update_s		::= 	update_part SET set_cols where_part
				  | 	update_part error {: TError errors_found = new TError("",0,0,"Syntax Error","Syntax error in update statement");
				  	  			 			 TableSE.add(errors_found); :};

update_part		::= 	UPDATE table_name;

set_cols		::= 	col:col1 _EQU value _COMMA set_cols {: Columns.add(col1 + ""); :} 
		  	  	  | 	col:col1 _EQU value		    	 	{: Columns.add(col1 + ""); :};


value 			::= 	INTEGER
				  | 	REAL
				  | 	LITERAL_STRING
				  | 	col;


/* DELETE */

delete_s		::= 	DELETE FROM table_name where_part
				  | 	DELETE error {: TError errors_found = new TError("",0,0,"Syntax Error","Syntax error in delete statement");
				  	  			 					TableSE.add(errors_found); :};




/* FROM: single and multiple tables */


from_part		::= 	_from table_name_mult;

table_name_mult ::= 	table_name _COMMA table_name_mult
				  |     table_name;

_from			::= 	FROM;



/* TABLE NAMES */

table_name		::= 	tab 
				  | 	tab IDENTIFIER;
				  
tab				::= 	IDENTIFIER:id {: Tables.add(id+""); :}
				  | 	QTABLENAME:id {: Tables.add(id.toString().replace("\"", "")); :};




/* WHERE */

where_part		::= 	_where w_condition;  

_where			::=		WHERE;

w_condition		::= 	cond log_oper w_condition
		  	  	  | 	cond;

cond 			::= 	element ari_oper element;

element    		::= 	IDENTIFIER
		  	  	  | 	INTEGER
		  	  	  | 	REAL
		  	  	  | 	LITERAL_STRING
		  	  	  | 	TABDOTCOL;

ari_oper  		::= 	_EQU 
		  	  	  | 	_GT 
		  	  	  | 	_LT 
		  	  	  | 	_LET 
		  	  	  | 	_GET 
		  	  	  | 	_DIFF;

log_oper    	::= 	_AND 
			  	  | 	_OR;
