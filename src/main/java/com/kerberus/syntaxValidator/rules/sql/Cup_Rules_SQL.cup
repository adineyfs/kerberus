/* ---------------------- 1st Part: User Code --------------------------------------------*/
package com.kerberus.syntaxValidator.rules.sql;

import java_cup.runtime.*; //Just import Symbols, maybe it's the only one we need
//import java.util.*;
import java.util.LinkedList;
import java.io.*;
import com.kerberus.syntaxValidator.rules.util.*;

// ---------------------- Code for parser,variables and methods ----------------------
parser code
{:
	// This list will hold every error found in the syntax analysis process. SE -> Syntax errors
	public static LinkedList<TError> TableSE = new LinkedList<TError>();

	// Recoverable syntax errors - This method will take case of the errors, and notify about it
	public void syntax_error(Symbol s) 
	{
		String lexeme = s.value.toString();
		int column = s.right;
		int row = s.left;
		
		System.out.println("### - Syntax error detected - ###\n");
		System.out.println("---> Unexpected: " + lexeme + " at (row,colum): ("+row+"," + column + ").");
		
		TError errors_found = new TError(lexeme,row,column, "Syntax error", "Unexpected " + lexeme);
		TableSE .add(errors_found);
	}
	
	// Unrecoverable syntax errors - This method will catch any other errors that go beyond our language(exceptions)
	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
	{
		/*
		String lexeme = s.value.toString();
		int row = s.right;
		int column = s.left;
		
		System.out.println("### Syntax error captured ###");
		System.out.println("### - Unrecoverable syntax error detected - ###");
		System.out.println("\t\tLexeme:" + lexeme);
		System.out.println("\t\tRow: " + row);
		System.out.println("\t\tColumn: " + column);
		
		TError errors_found = new TError(lexeme,row,column, "Unrecoverable syntax error", "Unexpected character");
		TableSE .add(errors_found);
		*/
	}	
	
:}

// -------------- Code for grammatical actions ------------------------------------------

action code 
{:
	
:}

/*---------------------- 2nd Part: Declarations --------------------------------------------*/

// Reserved words
terminal SELECT, UPDATE, DELETE, FROM, WHERE;

// Identifiers and numbers
terminal identifier, integer, real;

// Star symbol (all)
terminal _STAR;

// Operators 
terminal _EQU, _GT, _LT, _LET, _GET, _DIFF;

// Logial
terminal _AND,_OR,_NOT;

// Separator
terminal _COMMA;

// Statement closure
terminal _SEMCOL1,_SEMCOL2;

// Cup's internal
//terminal EOF; 		// <---  this is already declared in CUP's code

// Tree branches
non terminal _START_,_SELS_,_COLS_,_FRO_,_TABLE_,_SEL_;
non terminal _WHE_,_WC_,_COND_,_OPER_,_LC_,_EL_,_SC_;

/* 
 * Precedence definition --> this is used when the grammar is ambiguous
 * The priority of the elements has the highest value starting from the bottom 
 */ 
// precedence left operator1;
// precedence left operator2;
// precedence left operator3;
// precedence left operator4;

// Define which is the first production
start with _START_;

/*---------------------- 3rd Part: Semantic Rules --------------------------------------------*/

/* ------------ ToDo: Evaluate this --------------------------------------*/



_START_ ::= _SELS_ 
		  | _SELS_ _SC_; // SELECT [Columns] FROM [table] WHERE [Condition]
		  //| _UPDS_
		  //| _DELS_

_SELS_ 	::= _SEL_ _FRO_ _WHE_ /*_SC_*/;

_SEL_ 	::= SELECT _COLS_;

_COLS_	::= identifier _COMMA _COLS_  
		  | identifier:col{: System.out.println("Column: " + col + " found in (x,y): ("+ colleft +","+ colright +")"); :}
		  | _STAR;

_FRO_	::= FROM _TABLE_;

_TABLE_	::= identifier;

_WHE_   ::= WHERE _WC_;  

_WC_	::= _COND_ _LC_ _WC_
		  | _COND_;

_COND_ 	::= _EL_ _OPER_ _COND_
		  | _EL_;

_EL_    ::= identifier
		  | integer
		  | real;

_OPER_  ::= _EQU 
		  | _GT 
		  | _LT 
		  | _LET 
		  | _GET 
		  | _DIFF;

_LC_    ::= _AND | _OR;

_SC_	::= _SEMCOL2;




/*
	// NULLPOINTER Exception not solved

_START_ ::= _STMNT_ ; // Statement finishing with semicolon (should we force this??)

_STMNT_ ::= _SEL2_ 
		  | SELECT _COLS_ _FRO_ _WHE_;				

_SEL2_	::= SELECT  WHERE _SEMCOL ;						

//_SC_	::= _SEMCOL;

_COLS_	::= identifier 
		  | _COLS_ _COMMA identifier;

//_FRO_	::= FROM _TABLE_;

_WHE_   ::= WHERE _WC_;  

_WC_	::= _COND_ _LC_ _WC_
		  | _COND_;

_COND_ 	::= _EL_ _OPER_ _EL_;

_TABLE_	::= identifier;

_EL_    ::= identifier
		  | integer
		  | real;

_OPER_  ::= _EQU 
		  | _GT 
		  | _LT 
		  | _LET 
		  | _GET 
		  | _DIFF;

_LC_    ::= _AND | _OR;
*/