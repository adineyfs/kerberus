/* ---------------------- 1st Part: User Code --------------------------------------------*/
package com.kerberus.syntaxValidator.rules.sql;

import java_cup.runtime.*; //Just import Symbols, maybe it's the only one we need
//import java.util.*;
import java.util.LinkedList;
import java.io.*;
import com.kerberus.syntaxValidator.rules.util.*;

// ---------------------- Code for parser,variables and methods ----------------------
parser code
{:
	// This list will hold every error found in the syntax analysis process. SE -> Syntax errors
	public static LinkedList<TError> TableSE = new LinkedList<TError>();

	// Recoverable syntax errors - This method will take case of the errors, and notify about it
	public void syntax_error(Symbol s)
	{
		String lexeme = s.value.toString();
		int row = s.right;
		int column = s.left;
		
		System.out.println("### - Syntax error detected - ###");
		System.out.println("\t\tLexeme:" + lexeme);
		System.out.println("\t\tRow: " + row);
		System.out.println("\t\tColumn: " + column);
		
		TError errors_found = new TError(lexeme,row,column, "Syntax error", "Unexpected character");
		TableSE .add(errors_found);
	}
	
	// Unrecoverable syntax errors - This method will catch any other errors that go beyond our language(exceptions)
	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
	{
		String lexeme = s.value.toString();
		int row = s.right;
		int column = s.left;
		
		System.out.println("### Syntax error captured ###");
		System.out.println("### - Unrecoverable syntax error detected - ###");
		System.out.println("\t\tLexeme:" + lexeme);
		System.out.println("\t\tRow: " + row);
		System.out.println("\t\tColumn: " + column);
		
		TError errors_found = new TError(lexeme,row,column, "Unrecoverable syntax error", "Unexpected character");
		TableSE .add(errors_found);
	}	
	
:}

// -------------- Code for grammatical actions ------------------------------------------

action code 
{:
	
:}

/*---------------------- 2nd Part: Declarations --------------------------------------------*/
terminal SELECT, UPDATE, DELETE, FROM, WHERE,_STAR,_COMMA;
terminal identifier, integer, real;

non terminal _SEL1_,_COLS_,_FRO_,_TABLE_,_START_,_STMNT_;

/* 
 * Precedence definition --> this is used when the grammar is ambiguous
 * The priority of the elements has the highest value starting from the bottom 
 */ 
// precedence left operator1;
// precedence left operator2;
// precedence left operator3;
// precedence left operator4;

// Define which is the first production
start with _START_;

/*---------------------- 3rd Part: Semantic Rules --------------------------------------------*/

/* ------------ ToDo: Evaluate this --------------------------------------*/

_START_ ::= _STMNT_ {: System.out.println("\n --> Statement Ok"); :};

_STMNT_ ::= SELECT _COLS_ _FRO_ ;

_COLS_	::= _COLS_ _COMMA identifier 
		  | identifier:col{: System.out.println("Column: " + col + " found in (x,y): ("+ colleft +","+ colright +")"); :}
		  | _STAR;

_FRO_	::= FROM _TABLE_;

_TABLE_	::= identifier:id;



/*
 * Just testing NullPointer problem
 */
/*
_START_ ::= _STMNT_ {: System.out.println("Document Ok"); :};

_STMNT_ ::= _COLS_ _COMMA identifier:word {: System.out.println("Word: " + word + " found in (x,y): ("+ wordleft +","+ wordright +")"); :}
	   | identifier:word {: System.out.println("Word: " + word + " found in (x,y): ("+ wordleft +","+ wordright +")"); :};
*/